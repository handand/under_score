<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>WebRTC Chat â€” Manual Copy/Paste Signaling</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22c55e;
      --accent-2: #06b6d4;
      --border: #1f2937;
      --danger: #ef4444;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 100% -10%, #0b1220 10%, var(--bg) 60%);
      color: var(--text);
    }
    .container {
      max-width: 1100px;
      margin: 0 auto;
      padding: 28px 16px 80px;
    }
    h1 {
      margin: 0 0 12px;
      font-size: 28px;
      letter-spacing: 0.2px;
    }
    p.lead { color: var(--muted); margin-top: 0; }
    .status {
      display: grid;
      grid-template-columns: repeat(2, minmax(160px, 1fr));
      gap: 10px 16px;
      padding: 12px 14px;
      border: 1px solid var(--border);
      background: linear-gradient(180deg, #0f172a, #0d1627);
      border-radius: 10px;
      margin-bottom: 16px;
      font-size: 14px;
    }
    .status span.value { color: #f8fafc; font-variant-numeric: tabular-nums; }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }
    @media (min-width: 900px) {
      .grid { grid-template-columns: 1fr 1fr; }
    }
    .card {
      background: linear-gradient(180deg, #0b1220, #0e1423);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 14px;
    }
    .card h2, .card h3 { margin: 6px 0 10px; font-size: 18px; }
    .row { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    textarea, input[type="text"] {
      width: 100%;
      color: var(--text);
      background: #0a1020;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px 12px;
      outline: none;
      resize: vertical;
      min-height: 100px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
    }
    textarea[readonly] { opacity: 0.9; }
    button {
      background: #0b1020;
      color: var(--text);
      border: 1px solid var(--border);
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      transition: border-color .15s ease, transform .02s ease;
      user-select: none;
    }
    button:hover { border-color: #2a3a54; }
    button:active { transform: translateY(1px); }
    button.primary { border-color: #1f9a50; background: linear-gradient(180deg, #17331f, #0f2216); }
    button.secondary { border-color: #0c5360; background: linear-gradient(180deg, #0b2830, #0b1c22); }
    button.danger { border-color: #6b1212; background: linear-gradient(180deg, #2b0f13, #1a0a0c); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }
    .mono { white-space: pre-wrap; word-break: break-word; background: #0a1020; border: 1px solid var(--border); border-radius: 10px; padding: 10px; min-height: 100px; }
    .log { height: 220px; overflow: auto; background: #070c18; border: 1px solid var(--border); border-radius: 10px; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 13px; }
    .msg { margin: 0 0 8px; display: flex; gap: 8px; align-items: baseline; }
    .msg .who { color: var(--muted); min-width: 70px; text-align: right; }
    .msg .text { color: var(--text); }
    details { margin: 12px 0 16px; }
    summary { cursor: pointer; color: var(--muted); }
    footer { margin-top: 18px; color: var(--muted); font-size: 13px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebRTC Chat (Manual Signaling)</h1>
    <p class="lead">Two browsers, no server. Share Offer/Answer by copy/paste. Wait for ICE gathering to say "complete" before copying.</p>

    <div class="status">
      <div>Role: <span id="role" class="value">-</span></div>
      <div>Signaling: <span id="signalingState" class="value">-</span></div>
      <div>ICE gathering: <span id="iceGatheringState" class="value">-</span></div>
      <div>ICE connection: <span id="iceConnectionState" class="value">-</span></div>
      <div>Peer connection: <span id="connectionState" class="value">-</span></div>
    </div>

    <div class="grid">
      <section class="card">
        <h2>Caller side</h2>
        <div class="row" style="margin-bottom:8px;">
          <button id="btnCreateOffer" class="primary">Create Offer</button>
          <button id="btnCopyOffer" class="secondary" disabled>Copy Offer</button>
        </div>
        <textarea id="localOffer" placeholder="Your local Offer (send this to the remote peer)" readonly></textarea>
        <div style="height:8px;"></div>
        <textarea id="remoteAnswer" placeholder="Paste the remote Answer here"></textarea>
        <div class="row" style="margin-top:8px;">
          <button id="btnSetRemoteAnswer">Set Remote Answer</button>
        </div>
      </section>

      <section class="card">
        <h2>Callee side</h2>
        <textarea id="remoteOffer" placeholder="Paste the remote Offer here"></textarea>
        <div class="row" style="margin:8px 0;">
          <button id="btnSetRemoteOffer" class="primary">Set Remote Offer</button>
          <button id="btnCreateAnswer" class="secondary" disabled>Create Answer</button>
          <button id="btnCopyAnswer" class="secondary" disabled>Copy Answer</button>
        </div>
        <textarea id="localAnswer" placeholder="Your local Answer (send this to the caller)" readonly></textarea>
      </section>
    </div>

    <details>
      <summary>Optional: Manually exchange ICE candidates (only if connection fails)</summary>
      <div class="grid" style="margin-top:10px;">
        <section class="card">
          <h3>Local ICE candidates to share</h3>
          <div class="row" style="margin-bottom:8px;">
            <button id="btnCopyCandidates" disabled>Copy All Candidates</button>
          </div>
          <pre id="localCandidates" class="mono"></pre>
        </section>
        <section class="card">
          <h3>Paste remote ICE candidates (one JSON per line)</h3>
          <textarea id="remoteCandidates" placeholder='{"candidate":"candidate:...","sdpMid":"0","sdpMLineIndex":0}'></textarea>
          <div class="row" style="margin-top:8px;">
            <button id="btnAddCandidates">Add Candidates</button>
          </div>
        </section>
      </div>
    </details>

    <section class="card">
      <h2>Chat</h2>
      <div id="chatLog" class="log"></div>
      <div class="row" style="margin-top:10px;">
        <input type="text" id="chatInput" placeholder="Type a message and press Enter" disabled>
        <button id="btnSend" disabled>Send</button>
        <button id="btnReset" class="danger">Reset</button>
      </div>
    </section>

    <footer>
      Usage: Caller clicks "Create Offer" and sends the Offer. Callee pastes Offer and clicks "Set Remote Offer", then clicks "Create Answer" and sends it back. Caller pastes Answer and clicks "Set Remote Answer". Wait for ICE gathering to say "complete" before copying.
    </footer>
  </div>

  <script>
    // Elements
    const els = {
      role: document.getElementById('role'),
      signalingState: document.getElementById('signalingState'),
      iceGatheringState: document.getElementById('iceGatheringState'),
      iceConnectionState: document.getElementById('iceConnectionState'),
      connectionState: document.getElementById('connectionState'),

      btnCreateOffer: document.getElementById('btnCreateOffer'),
      btnCopyOffer: document.getElementById('btnCopyOffer'),
      localOffer: document.getElementById('localOffer'),
      remoteAnswer: document.getElementById('remoteAnswer'),
      btnSetRemoteAnswer: document.getElementById('btnSetRemoteAnswer'),

      remoteOffer: document.getElementById('remoteOffer'),
      btnSetRemoteOffer: document.getElementById('btnSetRemoteOffer'),
      btnCreateAnswer: document.getElementById('btnCreateAnswer'),
      btnCopyAnswer: document.getElementById('btnCopyAnswer'),
      localAnswer: document.getElementById('localAnswer'),

      localCandidates: document.getElementById('localCandidates'),
      remoteCandidates: document.getElementById('remoteCandidates'),
      btnCopyCandidates: document.getElementById('btnCopyCandidates'),
      btnAddCandidates: document.getElementById('btnAddCandidates'),

      chatLog: document.getElementById('chatLog'),
      chatInput: document.getElementById('chatInput'),
      btnSend: document.getElementById('btnSend'),
      btnReset: document.getElementById('btnReset'),
    };

    // WebRTC state
    let pc = null;
    let dataChannel = null;
    let lastAction = null; // 'offering' | 'answering'
    let role = 'idle';

    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 0
    };

    function updateStatus() {
      if (!pc) {
        els.role.textContent = 'idle';
        els.signalingState.textContent = '-';
        els.iceGatheringState.textContent = '-';
        els.iceConnectionState.textContent = '-';
        els.connectionState.textContent = '-';
        return;
      }
      els.role.textContent = role;
      els.signalingState.textContent = pc.signalingState;
      els.iceGatheringState.textContent = pc.iceGatheringState;
      els.iceConnectionState.textContent = pc.iceConnectionState;
      els.connectionState.textContent = pc.connectionState;
    }

    function descriptionToJson(desc) {
      return JSON.stringify({ type: desc.type, sdp: desc.sdp }, null, 2);
    }

    function parseDescription(str) {
      const obj = JSON.parse(str);
      if (!obj || !obj.type || !obj.sdp) throw new Error('Invalid description JSON');
      return obj;
    }

    function setTextareaValue(id, value) {
      const el = typeof id === 'string' ? document.getElementById(id) : id;
      el.value = value;
    }

    function enable(elOrId, enabled) {
      const el = typeof elOrId === 'string' ? document.getElementById(elOrId) : elOrId;
      el.disabled = !enabled;
    }

    function copyToClipboard(text) {
      if (!text) return;
      navigator.clipboard?.writeText(text).catch(() => {
        const ta = document.createElement('textarea');
        ta.style.position = 'fixed';
        ta.style.left = '-10000px';
        ta.value = text;
        document.body.appendChild(ta);
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
      });
    }

    function log(who, message) {
      const row = document.createElement('div');
      row.className = 'msg';
      const whoEl = document.createElement('span');
      whoEl.className = 'who';
      whoEl.textContent = who + ':';
      const textEl = document.createElement('span');
      textEl.className = 'text';
      textEl.textContent = message;
      row.appendChild(whoEl);
      row.appendChild(textEl);
      els.chatLog.appendChild(row);
      els.chatLog.scrollTop = els.chatLog.scrollHeight;
    }

    function setChatEnabled(enabled) {
      els.chatInput.disabled = !enabled;
      els.btnSend.disabled = !enabled;
      if (enabled) {
        els.chatInput.focus();
      }
    }

    function appendLocalCandidate(c) {
      const line = JSON.stringify({ candidate: c.candidate, sdpMid: c.sdpMid, sdpMLineIndex: c.sdpMLineIndex });
      els.localCandidates.textContent += (els.localCandidates.textContent ? '\n' : '') + line;
      enable(els.btnCopyCandidates, true);
    }

    function createPeerConnection(isCaller) {
      if (pc) {
        try { pc.close(); } catch (_) {}
      }
      pc = new RTCPeerConnection(rtcConfig);
      role = isCaller ? 'caller' : 'callee';
      updateStatus();

      pc.onicegatheringstatechange = () => {
        updateStatus();
        if (pc.iceGatheringState === 'complete') {
          if (lastAction === 'offering' && pc.localDescription) {
            setTextareaValue(els.localOffer, descriptionToJson(pc.localDescription));
            enable(els.btnCopyOffer, true);
          } else if (lastAction === 'answering' && pc.localDescription) {
            setTextareaValue(els.localAnswer, descriptionToJson(pc.localDescription));
            enable(els.btnCopyAnswer, true);
          }
          enable(els.btnCopyCandidates, true);
        }
      };

      pc.oniceconnectionstatechange = updateStatus;
      pc.onconnectionstatechange = updateStatus;
      pc.onsignalingstatechange = updateStatus;

      pc.onicecandidate = (ev) => {
        if (ev.candidate) appendLocalCandidate(ev.candidate);
      };

      pc.ondatachannel = (ev) => {
        dataChannel = ev.channel;
        wireDataChannel();
      };

      return pc;
    }

    function wireDataChannel() {
      if (!dataChannel) return;
      dataChannel.onopen = () => {
        log('System', 'Data channel open');
        setChatEnabled(true);
      };
      dataChannel.onmessage = (ev) => log('Peer', String(ev.data ?? ''));
      dataChannel.onclose = () => {
        log('System', 'Data channel closed');
        setChatEnabled(false);
      };
      dataChannel.onerror = (e) => console.error('DataChannel error', e);
    }

    async function handleCreateOffer() {
      try {
        if (!pc) createPeerConnection(true);
        if (!dataChannel) {
          dataChannel = pc.createDataChannel('chat');
          wireDataChannel();
        }
        lastAction = 'offering';
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        setTextareaValue(els.localOffer, descriptionToJson(pc.localDescription));
        enable(els.btnCopyOffer, true);
        updateStatus();
      } catch (err) {
        console.error(err);
        alert('Failed to create offer. See console.');
      }
    }

    async function handleSetRemoteAnswer() {
      try {
        if (!pc) throw new Error('Create an offer first');
        const ansStr = els.remoteAnswer.value.trim();
        if (!ansStr) return alert('Paste remote Answer JSON first');
        const answer = parseDescription(ansStr);
        await pc.setRemoteDescription(answer);
        log('System', 'Remote answer set. Connecting...');
        updateStatus();
      } catch (err) {
        console.error(err);
        alert('Failed to set remote answer. See console.');
      }
    }

    async function handleSetRemoteOffer() {
      try {
        const offStr = els.remoteOffer.value.trim();
        if (!offStr) return alert('Paste remote Offer JSON first');
        if (!pc) createPeerConnection(false);
        const offer = parseDescription(offStr);
        await pc.setRemoteDescription(offer);
        enable(els.btnCreateAnswer, true);
        log('System', 'Remote offer set. Ready to create answer.');
        updateStatus();
      } catch (err) {
        console.error(err);
        alert('Failed to set remote offer. See console.');
      }
    }

    async function handleCreateAnswer() {
      try {
        if (!pc) throw new Error('Set remote Offer first');
        lastAction = 'answering';
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        setTextareaValue(els.localAnswer, descriptionToJson(pc.localDescription));
        enable(els.btnCopyAnswer, true);
        updateStatus();
      } catch (err) {
        console.error(err);
        alert('Failed to create answer. See console.');
      }
    }

    function handleCopy(el) {
      copyToClipboard(el.value);
    }

    function handleCopyCandidates() {
      copyToClipboard(els.localCandidates.textContent);
    }

    async function handleAddCandidates() {
      try {
        if (!pc) throw new Error('No peer connection');
        const text = els.remoteCandidates.value.trim();
        if (!text) return;
        const lines = text.split('\n').map(s => s.trim()).filter(Boolean);
        for (const line of lines) {
          const cand = JSON.parse(line);
          await pc.addIceCandidate(cand);
        }
        els.remoteCandidates.value = '';
        log('System', `Added ${lines.length} remote candidate(s).`);
      } catch (err) {
        console.error(err);
        alert('Failed adding one or more candidates. See console.');
      }
    }

    function handleSend() {
      const msg = els.chatInput.value;
      if (!msg) return;
      if (!dataChannel || dataChannel.readyState !== 'open') {
        return alert('Data channel is not open yet');
      }
      dataChannel.send(msg);
      log('You', msg);
      els.chatInput.value = '';
      els.chatInput.focus();
    }

    function resetAll() {
      try { if (dataChannel) dataChannel.close(); } catch(_) {}
      try { if (pc) pc.close(); } catch(_) {}
      pc = null;
      dataChannel = null;
      lastAction = null;
      role = 'idle';
      // Clear UI
      els.localOffer.value = '';
      els.remoteAnswer.value = '';
      els.remoteOffer.value = '';
      els.localAnswer.value = '';
      els.localCandidates.textContent = '';
      els.remoteCandidates.value = '';
      els.chatLog.innerHTML = '';
      setChatEnabled(false);
      // Buttons
      enable(els.btnCopyOffer, false);
      enable(els.btnCopyAnswer, false);
      enable(els.btnCreateAnswer, false);
      enable(els.btnCopyCandidates, false);
      updateStatus();
    }

    // Wire UI events
    els.btnCreateOffer.addEventListener('click', handleCreateOffer);
    els.btnCopyOffer.addEventListener('click', () => handleCopy(els.localOffer));
    els.btnSetRemoteAnswer.addEventListener('click', handleSetRemoteAnswer);

    els.btnSetRemoteOffer.addEventListener('click', handleSetRemoteOffer);
    els.btnCreateAnswer.addEventListener('click', handleCreateAnswer);
    els.btnCopyAnswer.addEventListener('click', () => handleCopy(els.localAnswer));

    els.btnCopyCandidates.addEventListener('click', handleCopyCandidates);
    els.btnAddCandidates.addEventListener('click', handleAddCandidates);

    els.btnSend.addEventListener('click', handleSend);
    els.chatInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleSend(); });
    els.btnReset.addEventListener('click', resetAll);

    // Init
    updateStatus();
  </script>
</body>
</html>
