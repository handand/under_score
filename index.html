<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Perfect Negotiation Demo (Data Channel & Non-Trickle ICE)</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: #f4f7f9;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            gap: 40px;
        }
        .container {
            background: #fff;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 600px;
        }
        h1, h2 {
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            margin-top: 0;
            color: #1a237e;
        }
        textarea {
            width: 100%;
            min-height: 150px;
            box-sizing: border-box;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            margin-bottom: 10px;
            white-space: pre;
            word-wrap: normal;
            overflow-x: scroll;
        }
        button {
            background-color: #3f51b5;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover:not(:disabled) {
            background-color: #303f9f;
        }
        button:disabled {
            background-color: #9e9e9e;
            cursor: not-allowed;
        }
        .step {
            margin-bottom: 25px;
        }
        .status-grid {
            display: grid;
            grid-template-columns: 180px 1fr;
            gap: 5px;
            font-size: 14px;
            margin-bottom: 20px;
        }
        .status-grid strong {
            color: #555;
        }
        .chat-box {
            border: 1px solid #ccc;
            background-color: #f9f9f9;
            min-height: 200px;
            padding: 10px;
            border-radius: 4px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        .chat-box div {
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 5px;
            max-width: 80%;
        }
        .chat-box .sent {
            background-color: #dcedc8;
            margin-left: auto;
            text-align: right;
        }
        .chat-box .received {
            background-color: #c5cae9;
        }
        .chat-controls {
            display: flex;
            gap: 10px;
        }
        .chat-controls input {
            flex-grow: 1;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .role-selector label {
            margin-right: 15px;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>WebRTC Data Channel Demo</h1>
    <p>Using the <strong>Perfect Negotiation</strong> pattern with <strong>Non-Trickle ICE</strong> and manual SDP copy-paste.</p>

    <div class="step">
        <h2>1. Connection Setup</h2>
        <div class="role-selector">
            <strong>Assign Role:</strong>
            <label><input type="radio" name="role" value="impolite" checked> Impolite (Starts the call)</label>
            <label><input type="radio" name="role" value="polite"> Polite</label>
        </div>
        <button id="createPeerConnectionBtn">Create Peer Connection</button>
    </div>

    <div class="step">
        <h2>2. Create & Exchange Session Description</h2>
        <button id="createOfferBtn" disabled>Create Offer</button>
        <p><strong>Your Local Session Description (JSON):</strong><br>Copy this and paste it into the remote peer's "Remote" box.</p>
        <textarea id="localSdpTextarea" readonly placeholder="Your Session Description (JSON) will appear here..."></textarea>

        <p><strong>Remote Session Description (JSON):</strong><br>Paste the JSON from the other peer here.</p>
        <textarea id="remoteSdpTextarea" placeholder="Paste remote Session Description (JSON) here..."></textarea>
        <button id="acceptSdpBtn" disabled>Accept Remote Description</button>
    </div>

    <div class="step">
        <h2>3. Connection Status</h2>
        <div class="status-grid">
            <strong>PeerConnection State:</strong> <span id="pcState">Idle</span>
            <strong>ICE Gathering State:</strong> <span id="iceGatheringState">Idle</span>
            <strong>ICE Connection State:</strong> <span id="iceConnectionState">Idle</span>
            <strong>Data Channel State:</strong> <span id="dataChannelState">Idle</span>
        </div>
    </div>

    <div class="step">
        <h2>4. Chat</h2>
        <div class="chat-box" id="chatBox"></div>
        <div class="chat-controls">
            <input type="text" id="messageInput" placeholder="Type a message..." disabled>
            <button id="sendBtn" disabled>Send</button>
        </div>
    </div>
</div>

<script>
// DOM Elements
const createPeerConnectionBtn = document.getElementById('createPeerConnectionBtn');
const createOfferBtn = document.getElementById('createOfferBtn');
const acceptSdpBtn = document.getElementById('acceptSdpBtn');
const localSdpTextarea = document.getElementById('localSdpTextarea');
const remoteSdpTextarea = document.getElementById('remoteSdpTextarea');
const messageInput = document.getElementById('messageInput');
const sendBtn = document.getElementById('sendBtn');
const chatBox = document.getElementById('chatBox');
const pcState = document.getElementById('pcState');
const iceGatheringState = document.getElementById('iceGatheringState');
const iceConnectionState = document.getElementById('iceConnectionState');
const dataChannelState = document.getElementById('dataChannelState');

// WebRTC Globals
let pc;
let dataChannel;
let isPolite;

// Perfect Negotiation Globals
let makingOffer = false;
let ignoreOffer = false;

const config = {
  iceServers: [{ urls: "stun:stun.l.google.com:19302" }],
};

// --- Main Setup ---
createPeerConnectionBtn.onclick = createPeerConnection;
createOfferBtn.onclick = async () => {
    try {
        dataChannel = pc.createDataChannel("chat");
        setupDataChannelEvents(dataChannel);
    } catch (err) {
        console.error("Error creating data channel:", err);
    }
};
acceptSdpBtn.onclick = handleRemoteSdp;

// --- WebRTC Logic ---

function createPeerConnection() {
    if (pc) {
        pc.close();
    }
    pc = new RTCPeerConnection(config);
    console.log("RTCPeerConnection created.");

    pc.onconnectionstatechange = () => pcState.textContent = pc.connectionState;
    pc.onicegatheringstatechange = () => iceGatheringState.textContent = pc.iceGatheringState;
    pc.oniceconnectionstatechange = () => iceConnectionState.textContent = pc.iceConnectionState;

    pc.onnegotiationneeded = handleNegotiationNeeded;
    pc.ondatachannel = (event) => {
        dataChannel = event.channel;
        console.log("Received data channel:", dataChannel.label);
        setupDataChannelEvents(dataChannel);
    };
    
    // **FIX START: Add a dummy track to stabilize ICE for data-only connections**
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const oscillator = audioContext.createOscillator();
    const dst = oscillator.connect(audioContext.createMediaStreamDestination());
    oscillator.start();
    const [track] = dst.stream.getAudioTracks();
    pc.addTrack(track, dst.stream);
    
    // The remote peer must handle this incoming track
    pc.ontrack = (event) => {
      console.log("Received remote dummy track.");
      // We don't need to do anything with it, just acknowledge it.
    };
    // **FIX END**

    pc.iceGatheringComplete = new Promise(resolve => {
        pc.onicecandidate = (e) => !e.candidate && resolve();
    });
    
    isPolite = document.querySelector('input[name="role"]:checked').value === 'polite';
    document.querySelectorAll('input[name="role"]').forEach(radio => radio.disabled = true);
    createPeerConnectionBtn.disabled = true;
    createOfferBtn.disabled = false;
    acceptSdpBtn.disabled = false;
}

async function handleNegotiationNeeded() {
    console.log("`negotiationneeded` event fired");
    try {
        makingOffer = true;
        await pc.setLocalDescription();
        await pc.iceGatheringComplete;
        console.log("ICE Gathering Complete. Offer is ready.");
        localSdpTextarea.value = JSON.stringify(pc.localDescription);
    } catch (err) {
        console.error("Error in handleNegotiationNeeded:", err);
    } finally {
        makingOffer = false;
    }
}

async function handleRemoteSdp() {
    const remoteSdpJson = remoteSdpTextarea.value;
    if (!remoteSdpJson) return alert("Remote Session Description is empty!");
    
    let description;
    try {
        description = JSON.parse(remoteSdpJson);
    } catch (e) {
        return alert("Invalid JSON in Remote Session Description.");
    }
    
    const offerCollision = description.type === "offer" && (makingOffer || pc.signalingState !== "stable");
    ignoreOffer = !isPolite && offerCollision;
    if (ignoreOffer) {
        console.log("Ignoring colliding offer as the impolite peer.");
        return;
    }

    try {
        await pc.setRemoteDescription(description);
        console.log("Remote description set.");

        if (description.type === "offer") {
            console.log("Received an offer, creating an answer.");
            await pc.setLocalDescription();
            await pc.iceGatheringComplete;
            console.log("ICE Gathering Complete. Answer is ready.");
            localSdpTextarea.value = JSON.stringify(pc.localDescription);
        }
    } catch (err) {
        console.error("Error handling remote SDP:", err);
    }
}

function setupDataChannelEvents(channel) {
    channel.onopen = () => {
        console.log("Data channel is open!");
        dataChannelState.textContent = channel.readyState;
        messageInput.disabled = false;
        sendBtn.disabled = false;
        createOfferBtn.disabled = true;
    };
    
    channel.onclose = () => {
        console.log("Data channel is closed.");
        dataChannelState.textContent = channel.readyState;
        messageInput.disabled = true;
        sendBtn.disabled = true;
    };

    channel.onmessage = (event) => {
        console.log("Received message:", event.data);
        appendMessage(event.data, 'received');
    };

    sendBtn.onclick = () => {
        const message = messageInput.value;
        if (message) {
            channel.send(message);
            appendMessage(message, 'sent');
            messageInput.value = '';
        }
    };
    
    messageInput.onkeypress = (e) => {
        if (e.key === 'Enter' && !sendBtn.disabled) {
            sendBtn.click();
        }
    };
}

function appendMessage(message, type) {
    const messageEl = document.createElement('div');
    messageEl.textContent = message;
    messageEl.className = type;
    chatBox.appendChild(messageEl);
    chatBox.scrollTop = chatBox.scrollHeight;
}
</script>

</body>
</html>
